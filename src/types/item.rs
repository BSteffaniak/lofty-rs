use crate::TagType;

#[derive(PartialEq)]
#[allow(missing_docs)]
pub enum ItemKey {
	Artist,
	AlbumTitle,
	AlbumArtist,
	Composer,
	Comment,
	Copyright,
	Bpm,
	RecordingDate,
	ReleaseDate,
	Year,
	TotalDiscs,
	DiscNumber,
	Encoder,
	Genre,
	Lyrics,
	Lyricist,
	Title,
	TotalTracks,
	TrackNumber,
	Unknown(String),
}

impl ItemKey {
	/// Map a format specific key to an ItemKey
	pub fn from_key(tag_type: &TagType, key: &str) -> Option<Self> {
		match tag_type {
			TagType::Ape => match &*key.to_uppercase() {
				"ARTIST" => Some(Self::Artist),
				"ALBUM" => Some(Self::AlbumTitle),
				"ALBUM ARTIST" => Some(Self::AlbumArtist),
				"COMPOSER" => Some(Self::Composer),
				"COPYRIGHT" => Some(Self::Copyright),
				"COMMENT" => Some(Self::Comment),
				"BPM" => Some(Self::Bpm),
				"DATE" => Some(Self::ReleaseDate),
				"YEAR" => Some(Self::Year),
				"DISC" => Some(Self::DiscNumber),
				"ENCODER" => Some(Self::Encoder),
				"GENRE" => Some(Self::Genre),
				"LYRICS" => Some(Self::Lyrics),
				"LYRICIST" => Some(Self::Lyricist),
				"TITLE" => Some(Self::Title),
				"TRACK" => Some(Self::TrackNumber),
				unknown => Some(Self::Unknown(unknown.to_string())),
			},
			TagType::Id3v1 => None,
			TagType::Id3v2 => match &*key.to_uppercase() {
				"TPE1" => Some(Self::Artist),
				"TALB" => Some(Self::AlbumTitle),
				"TPE2" => Some(Self::AlbumArtist),
				"TCOM" => Some(Self::Composer),
				"TCOP" => Some(Self::Copyright),
				"COMM" => Some(Self::Comment),
				"TBPM" => Some(Self::Bpm),
				"TDRC" => Some(Self::RecordingDate),
				"TDOR" => Some(Self::ReleaseDate),
				"TYER" => Some(Self::Year),
				"TPOS" => Some(Self::DiscNumber),
				"TSSE" => Some(Self::Encoder),
				"TCON" => Some(Self::Genre),
				"USLT" => Some(Self::Lyrics),
				"TEXT" => Some(Self::Lyricist),
				"TIT2" => Some(Self::Title),
				"TRCK" => Some(Self::TrackNumber),
				_ => None,
			},
			TagType::Mp4Atom => match key {
				"\u{a9}ART" => Some(Self::Artist),
				"\u{a9}alb" => Some(Self::AlbumTitle),
				"aART" => Some(Self::AlbumArtist),
				"\u{a9}wrt" => Some(Self::Composer),
				"cprt" => Some(Self::Copyright),
				"©cmt" => Some(Self::Comment),
				"tmpo" => Some(Self::Bpm),
				"\u{a9}day" => Some(Self::RecordingDate),
				"disk" => Some(Self::DiscNumber),
				"\u{a9}too" => Some(Self::Encoder),
				"\u{a9}gen" => Some(Self::Genre),
				"\u{a9}lyr" => Some(Self::Lyrics),
				"----:com.apple.iTunes:LYRICIST" => Some(Self::Lyricist),
				"\u{a9}nam" => Some(Self::Title),
				"trkn" => Some(Self::TrackNumber),
				_ => None,
			},
			TagType::VorbisComments => match &*key.to_uppercase() {
				"ARTIST" => Some(Self::Artist),
				"ALBUMTITLE" => Some(Self::AlbumTitle),
				"ALBUMARTIST" => Some(Self::AlbumArtist),
				"COMPOSER" => Some(Self::Composer),
				"COPYRIGHT" => Some(Self::Copyright),
				"COMMENT" => Some(Self::Comment),
				"BPM" => Some(Self::Bpm),
				"DATE" => Some(Self::RecordingDate),
				"YEAR" => Some(Self::Year),
				"ORIGINALDATE" => Some(Self::ReleaseDate),
				"TOTALDISCS" => Some(Self::TotalDiscs),
				"DISCNUMBER" => Some(Self::DiscNumber),
				"ENCODER" => Some(Self::Encoder),
				"GENRE" => Some(Self::Genre),
				"LYRICS" => Some(Self::Lyrics),
				"LYRICIST" => Some(Self::Lyricist),
				"TITLE" => Some(Self::Title),
				"TOTALTRACKS" => Some(Self::TotalTracks),
				"TRACKNUMBER" => Some(Self::TrackNumber),
				unknown => Some(Self::Unknown(unknown.to_string())),
			},
			TagType::RiffInfo => match &*key.to_uppercase() {
				"IART" => Some(Self::Artist),
				"IPRD" => Some(Self::AlbumTitle),
				"ICOP" => Some(Self::Copyright),
				"ICMT" => Some(Self::Comment),
				"ICRD" => Some(Self::RecordingDate),
				"ISFT" => Some(Self::Encoder),
				"IGNR" => Some(Self::Genre),
				"INAM" => Some(Self::Title),
				"IFRM" => Some(Self::TotalTracks),
				"ITRK" => Some(Self::TrackNumber),
				_ => None,
			},
			TagType::AiffText => match key {
				"AUTH" => Some(Self::Artist),
				"(c) " => Some(Self::Copyright),
				"NAME" => Some(Self::Title),
				_ => None,
			},
		}
	}
	/// Maps the variant to a format-specific key
	///
	/// # Returns
	///
	/// Will return `None` if no mapping is found
	pub fn map_key(&self, tag_type: &TagType) -> Option<&str> {
		match tag_type {
			TagType::Ape => match self {
				Self::Artist => Some("Artist"),
				Self::AlbumTitle => Some("Album"),
				Self::AlbumArtist => Some("Album Artist"),
				Self::Composer => Some("Composer"),
				Self::Copyright => Some("Copyright"),
				Self::Comment => Some("Comment"),
				Self::Bpm => Some("BPM"),
				Self::ReleaseDate => Some("Date"),
				Self::Year => Some("Year"),
				Self::TotalDiscs | Self::DiscNumber => Some("Disc"),
				Self::Encoder => Some("Encoder"),
				Self::Genre => Some("Genre"),
				Self::Lyrics => Some("Lyrics"),
				Self::Lyricist => Some("Lyricist"),
				Self::Title => Some("Title"),
				Self::TotalTracks | Self::TrackNumber => Some("Track"),
				Self::Unknown(ref unknown) => Some(unknown),
				_ => None,
			},
			TagType::Id3v1 => None,
			TagType::Id3v2 => match self {
				Self::Artist => Some("TPE1"),
				Self::AlbumTitle => Some("TALB"),
				Self::AlbumArtist => Some("TPE2"),
				Self::Composer => Some("TCOM"),
				Self::Copyright => Some("TCOP"),
				Self::Bpm => Some("TBPM"),
				Self::RecordingDate => Some("TDRC"),
				Self::ReleaseDate => Some("TDOR"),
				Self::Year => Some("TYER"),
				Self::TotalDiscs | Self::DiscNumber => Some("TPOS"),
				Self::Encoder => Some("TSSE"),
				Self::Genre => Some("TCON"),
				Self::Lyrics => Some("USLT"),
				Self::Lyricist => Some("TEXT"),
				Self::Title => Some("TIT2"),
				Self::TotalTracks | Self::TrackNumber => Some("TRCK"),
				_ => None,
			},
			TagType::Mp4Atom => match self {
				Self::Artist => Some("\u{a9}ART"),
				Self::AlbumTitle => Some("\u{a9}alb"),
				Self::AlbumArtist => Some("aART"),
				Self::Composer => Some("\u{a9}wrt"),
				Self::Copyright => Some("cprt"),
				Self::Comment => Some("©cmt"),
				Self::Bpm => Some("tmpo"),
				Self::RecordingDate | Self::Year => Some("\u{a9}day"),
				Self::TotalDiscs | Self::DiscNumber => Some("disk"),
				Self::Encoder => Some("\u{a9}too"),
				Self::Genre => Some("\u{a9}gen"),
				Self::Lyrics => Some("\u{a9}lyr"),
				Self::Lyricist => Some("----:com.apple.iTunes:LYRICIST"),
				Self::Title => Some("\u{a9}nam"),
				Self::TotalTracks | Self::TrackNumber => Some("trkn"),
				_ => None,
			},
			TagType::VorbisComments => match self {
				Self::Artist => Some("ARTIST"),
				Self::AlbumTitle => Some("ALBUMTITLE"),
				Self::AlbumArtist => Some("ALBUMARTIST"),
				Self::Composer => Some("COMPOSER"),
				Self::Copyright => Some("COPYRIGHT"),
				Self::Comment => Some("Comment"),
				Self::Bpm => Some("BPM"),
				Self::RecordingDate => Some("DATE"),
				Self::ReleaseDate => Some("ORIGINALDATE"),
				Self::Year => Some("YEAR"),
				Self::TotalDiscs => Some("TOTALDISCS"),
				Self::DiscNumber => Some("DISCNUMBER"),
				Self::Encoder => Some("ENCODER"),
				Self::Genre => Some("GENRE"),
				Self::Lyrics => Some("LYRICS"),
				Self::Lyricist => Some("LYRICIST"),
				Self::Title => Some("TITLE"),
				Self::TotalTracks => Some("TOTALTRACKS"),
				Self::TrackNumber => Some("TRACKNUMBER"),
				Self::Unknown(ref unknown) => Some(unknown),
			},
			TagType::RiffInfo => match self {
				Self::Artist => Some("IART"),
				Self::AlbumTitle => Some("IPRD"),
				Self::Copyright => Some("ICOP"),
				Self::Comment => Some("ICMT"),
				Self::RecordingDate => Some("ICRD"),
				Self::Encoder => Some("ISFT"),
				Self::Genre => Some("IGNR"),
				Self::Title => Some("INAM"),
				Self::TotalTracks => Some("IFRM"),
				Self::TrackNumber => Some("ITRK"),
				_ => None,
			},
			TagType::AiffText => match self {
				Self::Artist => Some("AUTH"),
				Self::Copyright => Some("(c) "),
				Self::Title => Some("NAME"),
				_ => None,
			},
		}
	}
}
